## 정렬 속성
#### 오름차순, 내림차순
대부분 오름차순을 디폴트로 놓는다. (여기서도 따로 언급이 없으면 오름차순을 기준으로 한다.)
#### 제자리 정렬 (in-place sort)
원소 개수에 비해 무시할 만큼 적은 공간만 추가적으로 사용한다.  
교환에 임시 공간이 하나가 필요하므로, 최소한 한 개는 추가로 필요하다.
#### 안정 정렬 (stable sort)
안정 정렬은 중복된 값들은 입력된 순서에 따라 정렬된다.
- 안정: 병합, 삽입, 버블 정렬 등
- 불안정: 퀵, 힙, 선택 정렬 등
## O(N^2)
### Bubble Sort (버블 소트)
모든 자리에 대해 뒤에서 앞으로 진행하며, (외부 for문)  
해당 자리 앞의 인접한 두 원소들을 차례로 비교한다. (내부 for문)  
```
for i in range(n-1, 0, -1):
    for j in range(i):
        if a[j] > a[j+1]:
            swap(a, j, j+1)

for i in range(n-1):
    for j in range(0, n-i-1):
        if a[j] > a[j+1]:
            swap(a, j, j+1)
```
- 외부 for문의 i 자리의 정렬이 순서대로 완료된다.
- 내부 for문은 반대쪽에서 i까지 진행해야 최종적으로 i에 맞는 값이 올라오므로,  
외부와 내부 for문의 방향은 반대여야 한다.  
(이렇게 값이 올라오는 모습에서 버블이라는 이름이 붙었다.)

버블 소트는 성능이 좋지 않으므로 실제로 쓰이는 상황은 거의 없다.  
다만 swap이 일어났는지 체크하여, 일어나지 않았으면 종료하도록 만들면,  
이미 정렬된 경우에 O(N)이 된다.
### Selection Sort (선택 정렬)
모든 자리에 대해, (외부 for문)  
해당 자리 뒤의 모든 원소들의 최솟값을 찾는다. (내부 for문)
```
for i in range(n-1):
    k = i
    for j in range(i+1, n):
        if a[k] > a[j]:
            k = j
    swap(a, i, k)
```
- 외부와 내부 for문의 방향이 반대일 필요가 없다.

주어진 자료의 상태에 관계없이 항상 동일한 시간이 걸린다.
#### Double Selection Sort (이중 선택 정렬)
내부 for문에서 최솟값과 최댓값을 동시에 찾아 양 끝으로 보낸다.  
따라서 외부 for문이 절반으로 줄어든다.
### Insertion Sort (삽입 정렬)
모든 자리의 원소에 대해, (외부 for문)  
해당 원소 앞의 원소들에서 가까운 것부터 비교하여 자리를 찾는다. (내부 for문)
```
for i in range(n-1):
    for j in range(i-1, -1, -1):
        if a[i] > a[j]:
            insert(a, i, j+1)
            break
```
- 원소를 넣을 자리를 찾았으며, 단순 교환이 아니라 삽입을 해야 한다.  
insert 함수는 원래의 i번째 원소를 j+1번째에 넣고,  
원래의 j+1번째부터 마지막까지의 원소를 한 칸씩 뒤로 밀어야 한다.  
따라서 자료구조에 따라 비용이 클 수 있다.
- 삽입을 했으면 현재 내부 for문을 빠져나온다.  
외부 for문의 i번째 자리는 순서대로 정렬이 완료되며,  
따라서 이전 자리들은 모두 정렬이 완료된 것이기 때문이다.

앞에 있어야할 원소가 뒤에 몰려 있는 경우에는 정렬 시간이 많이 걸릴 것이다.  
반면 이미 정렬된 자료구조에 원소를 하나씩 삽입하는 경우에는 O(N)의 시간복잡도를 갖는다.  
(맨 뒤에 넣고 가까운 것과 차례대로 비교한다.)  
M개의 원소를 삽입하는 경우는 O(MN)이다.  
  
이진 탐색을 이용하면 각각 O(logN)의 시간복잡도로 줄일 수 있다.
