## 정렬 속성
#### 오름차순, 내림차순
대부분 오름차순을 디폴트로 놓는다. (여기서도 따로 언급이 없으면 오름차순을 기준으로 한다.)
#### 제자리 정렬 (in-place sort)
원소 개수에 비해 무시할 만큼 적은 공간만 추가적으로 사용한다.  
교환에 임시 공간이 하나가 필요하므로, 최소한 한 개는 추가로 필요하다.
#### 안정 정렬 (stable sort)
안정 정렬은 중복된 값들은 입력된 순서에 따라 정렬된다.
- 안정: 병합, 삽입, 버블 정렬 등
- 불안정: 퀵, 힙, 선택 정렬 등
## O(N^2)
시간복잡도가 가장 큰 정렬들로, 단독으로 쓰일 일은 없다고 볼 수 있다.
### Bubble Sort (버블 소트)
모든 자리에 대해 뒤에서 앞으로 진행하며, (외부 for문)  
해당 자리 앞의 인접한 두 원소들을 차례로 비교한다. (내부 for문)  
```
for i in range(n-1, 0, -1):
    for j in range(i):
        if a[j] > a[j+1]:
            swap(a, j, j+1)

for i in range(n-1):
    for j in range(0, n-i-1):
        if a[j] > a[j+1]:
            swap(a, j, j+1)
```
- 외부 for문의 i 자리의 정렬이 순서대로 완료된다.
- 내부 for문은 반대쪽에서 i까지 진행해야 최종적으로 i에 맞는 값이 올라오므로,  
외부와 내부 for문의 방향은 반대여야 한다.  
(이렇게 값이 올라오는 모습에서 버블이라는 이름이 붙었다.)

버블 소트는 성능이 좋지 않으므로 실제로 쓰이는 상황은 거의 없다.  
다만 swap이 일어났는지 체크하여, 일어나지 않았으면 종료하도록 만들면,  
이미 정렬된 경우에 O(N)이 된다.
### Selection Sort (선택 정렬)
모든 자리에 대해, (외부 for문)  
해당 자리 뒤의 모든 원소들의 최솟값을 찾는다. (내부 for문)
```
for i in range(n-1):
    k = i
    for j in range(i+1, n):
        if a[k] > a[j]:
            k = j
    swap(a, i, k)
```
- 외부와 내부 for문의 방향이 반대일 필요가 없다.

주어진 자료의 상태에 관계없이 항상 동일한 시간이 걸린다.
#### Double Selection Sort (이중 선택 정렬)
내부 for문에서 최솟값과 최댓값을 동시에 찾아 양 끝으로 보낸다.  
따라서 외부 for문이 절반으로 줄어든다.
### Insertion Sort (삽입 정렬)
모든 자리의 원소에 대해, (외부 for문)  
해당 원소 앞의 원소들에서 가까운 것부터 비교하여 자리를 찾는다. (내부 for문)
```
for i in range(n-1):
    for j in range(i-1, -1, -1):
        if a[i] > a[j]:
            insert(a, i, j+1)
            break
```
- 원소를 넣을 자리를 찾았으며, 단순 교환이 아니라 삽입을 해야 한다.  
insert 함수는 원래의 i번째 원소를 j+1번째에 넣고,  
원래의 j+1번째부터 마지막까지의 원소를 한 칸씩 뒤로 밀어야 한다.  
따라서 자료구조에 따라 비용이 클 수 있다.
- 삽입을 했으면 현재 내부 for문을 빠져나온다.  
외부 for문의 i번째 자리는 순서대로 정렬이 완료되며,  
따라서 이전 자리들은 모두 정렬이 완료된 것이기 때문이다.

앞에 있어야할 원소가 뒤에 몰려 있는 경우에는 정렬 시간이 많이 걸릴 것이다.  
반면 이미 정렬된 자료구조에 원소를 하나씩 삽입하는 경우에는 O(N)의 시간복잡도를 갖는다.  
(맨 뒤에 넣고 가까운 것과 차례대로 비교한다.)  
M개의 원소를 삽입하는 경우는 O(MN)이다.  
  
[이진 탐색][1]을 이용하면 각각 O(logN)의 시간복잡도로 줄일 수 있다.

## O(N logN)
병합 정렬과 힙 소트는 최악의 경우에도 O(N logN)을 유지한다.  
반면 퀵 소트는 최악의 경우 O(N^2)의 시간복잡도를 갖는다.  
하지만 평균적으로는 둘 보다 빠른 O(N logN)이므로 큇 소트를 개량해서 사용하는 경우가 많다.
### Merge Sort (병합 정렬)
평균 성능은 퀵 소트보다 좋지 않고 두 배의 메모리 공간이 필요하다.  
그래도 안정 정렬이라는 장점을 갖는다.
```
def merge_sort(arr, l, r):
    if l < r:
        m = l + (r-l)//2
        merge_sort(arr, l, m)
        merge_sort(arr, m+1, r)
        merge(arr, l, m, r)

def merge(arr, l, m, r):
    n1, n2 = m - l + 1, r - m
    L, R = [0] * n1, [0] * n2
    # copy
    for i in range(n1):
        L[i] = arr[l + i]
    for j in range(n2):
        R[j] = arr[m + 1 + j]
    
    i, j, k = 0, 0, l
    # compare and merge
    while (i < n1) and (j < n2):
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    # merge remaining elements
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1
```
- `l + (r-l)//2`은 `(l + r) // 2`과 동일한데, l과 r이 클 때의 오버플로우를 방지할 수 있다.
- 대략 merge_sort는 분할, merge는 병합 과정으로 생각할 수 있다.  
최후까지 분할하여 역순으로 하나씩 병합한다.
- 따라서 병합 시에는 m을 기준으로 각자 정렬이 되어있는 상태다.  
병합 과정은 다음과 같다.
  - m을 기준으로 각각 새로운 공간에 백업한다. (L, R)  
  이후 L과 R의 값은 바꾸지 않고 비교에 사용할 것이다.
  - L과 R의 인덱스 i, j를 둘 다 0으로 초기화하고, arr의 인덱스는 k는 l로 초기화한다.  
  각 인덱스에 대한 L과 R의 값을 비교하여 더 작은 것을 arr에 넣는다. (같으면 L의 값을 넣는다.)  
  값을 넣은 것의 인덱스를 1 증가시키며, k도 1 증가시킨다.  
  i와 j가 범위를 벗어나지 않을 동안 반복한다. 
  - 인덱스가 범위를 벗어나면 L과 R 중 어느 하나의 원소가 남는다.  
  이것은 arr에 넣은 것들보다 크며, 이미 정렬되어 있으므로 arr에 바로 넣으면 된다.  
  (L과 R 각각은 분할, 병합에 의해 정렬이 된 상태이다.)

[1]: https://github.com/ipari3/CS/blob/main/Algorithm/Binary%20Search.md
