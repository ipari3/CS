## meaning
heap 구조는 최댓값 혹은 최솟값이 가장 위로 오도록 쌓는다는 의미에서 지어졌다.
heap 메모리나 Heap's 알고리즘과는 관련이 없다.
- heap memory: 아무렇게나 쌓아올린다는 의미를 가지며, stack과 달리 띄엄띄엄 공간을 점유할 수 있다.
- Heap's algorithm: 순열(permutation)을 구현하는 알고리즘이다.
#### Complete Binary Tree (완전 이진 트리)
힙 구조는 보통 이진 트리로 구현하며, 완전 이진 트리일 때 높이가 최소가 된다.  
완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져있다. (completely filled)  
일반적으로 왼쪽부터 채우며, 마지막 레벨은 가장 오른쪽 노드들이 비어있을 수 있다.
- **perfect binary tree**(포화 이진 트리): 마지막 레벨도 완전히 채워져 있다.  
즉, 모든 노드가 자식 노드를 두 개 갖고, 리프 노드들의 깊이 및 레벨이 같다.  
perfect가 아닌 complete 이진 트리는 almost complete 혹은 nearly complete 이진 트리라고도 한다.

완전 이진 트리는 인덱싱을 통해 부모나 자식 노드로의 이동이 가능하여 효율적이다.
인덱스가 0부터 시작하는 경우,
- 부모 노드: (i-1)/2
- 자식 노드: 2i + 1, 2i + 2 (left, right)
인덱스 0, 1, 2로 간단히 알아볼 수 있다.  
인덱스가 1부터 시작하는 경우는 1, 2, 3으로 알아보면 된다.

> **Full Binary Tree**(정 이진 트리): 모든 노드가 자식 노드를 0개나 2개 갖는다. (리프 노드를 제외한 노드가 자식 노드를 두 개 갖는다.)  
> Complete 이진 트리와는 달리, 왼쪽부터 채울 필요는 없으며, 리프 노드들의 깊이가 같을 필요도 없다.
>> internal node(내부 노드): 리프 노드가 아닌 노드를 내부 노드라고 한다.

- **이진 트리**: 이들을 포함하는 이진 트리는 각 노드의 자식 노드가 최대 두 개인 트리이다.
- **트리**: 이진 트리도 포함하는 트리 구조는 루트 노드와 자식 노드들의 서브트리의 재귀적 구조로 정의할 수 있다.  
각 노드는 값과 자식 노드에 대한 레퍼런스 리스트로 구성된 자료 구조이며, 루트 노드에서 시작한다.    
또한 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 그래프이다.  
두 노드가 오직 하나의 길(path)로만 연결된, 혹은 비순환(acyclic) 그래프라고 할 수 있다.    
트리는 무향(undirected) 그래프이며, 생성 규칙 혹은 제약이 있을 뿐이다.  
유향(directed) 트리는 근원(underlying) 무향 그래프가 트리인 유향 비순환 그래프이며,  
polytree, oriented tree, singly connected network 등으로도 불린다.
- **그래프**: 트리를 포함하는 그래프는 정점(vertex)와 간선(edge)의 집합이다.

## 구현
보통 이진 트리 구조로 구현하며, 최소힙과 최대힙은 각각 다음의 규칙을 따른다.
- 최소힙: 각 노드의 값이 자식 노드의 값보다 작거나 같다.
- 최대힙: 각 노드의 값이 자식 노드의 값보다 크거나 같다.
형제나 사촌 및 삼촌 노드 사이에는 순서가 없다.  
각각 최솟값/최댓값이 가장 위에 있으므로 최솟값/최댓값을 O(1) 시간에 찾을 수 있다.  
다만 해당 값을 빼내면 원소 삭제와 같은 O(N)의 시간이 걸린다.  
  
힙 구조에 원소를 하나 추가하는 방법은 다음과 같다.
1. 가장 끝 자리에 삽입한다.
2. 부모 노드와 비교하여 힙 규칙에 맞지 않으면 교환한다.
3. 힙 규칙에 맞을 때까지 반복한다.
시간복잡도는 트리의 높이인 O(logN)이다.  
이렇게 밑에 넣고 부모 노드와 비교하는 것을 **siftUp**이라고 한다.  
반대로 위에 넣고 자식 노드들과 비교하는 것은 **siftDown**이라고 하며,  
자식 노드들 중 더 작은/큰 것과 교환해야 한다.  
  
원소를 제거하는 방법은 다음과 같다.  
1. 가장 첫 자리(루트)의 원소를 제거한다.
2. 가장 끝 자리의 원소를 루트에 놓는다.
3. 자식 노드와 비교하여 힙 규칙에 맞도록 자식 노드와 교환한다.(더 작은/큰 값이 올라가도록)
4. 힙 규칙에 맞을 때까지 반복한다.
시간복잡도는 마찬가지로 O(logN)이다.  
  
정렬되지 않은 값들을 힙 구조로 만드는 것을 buildHeap 혹은 heapify라고 하며 방법은 다음과 같다.  
원소의 개수가 n이고 높이가 h인 perfect 이진 트리라고 가정하며, siftDown을 이용한다.
1. 맨 아래 레벨의 자리에 n/2개의 노드를 넣는다.  
비교할 자식 노드가 없으므로 연산량은 0·n/2이다.
2. 바로 윗 레벨의 자리에 n/4개의 노드를 넣는다.  
자식 노드들과 비교하는 siftDown을 하면 연산량은 1·n/4이다.
3. 맨 윗 레벨까지 반복한다.  
맨 윗 레벨의 루트 노드는 1개이며 트리의 높이만큼 비교하므로 연산량은 h·1이다.
총 연산량은 0·n/2 + 1·n/4 + ... + h·1이며, 시간복잡도는 O(N)이다.  
([외부에서 더 보기: *테일러 급수*를 이용한 증명][1])  
siftUp 방식으로 heapify하면 시간복잡도가 O(N logN)이 되므로,  
siftUp 방식은 원소 삽입 및 삭제에만 사용한다.  
  
힙 구조를 이용한 정렬인 힙 정렬의 시간복잡도는 O(N logN)이다.  
우선 힙 구조로 만드는 것은 O(N) 혹은 O(N log N)이다.  
그리고 최솟값/최댓값을 하나씩 빼는 것은 O(logK)이다. (K는 남은 노드 수이며, K <= N)  
따라서 모든 원소를 빼는 것은 log(1) + log(2) + ... + log(N) = log(N!)이며,  
*스털링 근사*에 따라 N log(N)으로 근사할 수 있다.  
따라서 heapify와 sort를 합쳐서 O(N logN)이다.
#### 시간복잡도
- 최솟값/최댓값 확인: O(1)
- 삽입, 삭제: O(logN)
- 힙 빌드: O(N)
- 힙 정렬: O(N logN)

## 사용
#### Priority Queue (우선순위 큐)
우선순위가 높은 원소부터 수행되며, 우선순위가 같은 경우 들어온 순서대로 수행된다.  
대부분의 경우 힙 구조로 구현되며, 대부분의 경우 힙 구조는 이진 트리 구조로 구현된다.
- 자바에서는 큐의 한 종류로서 `PriorityQueue` 컬렉션으로 구현되어 있다.
- 파이썬에서는 힙 구조를 이용한 큐라는 의미로 `heapq` 모듈로 구현되어 있다.
#### Dijkstra's algorithm
다익스트라 알고리즘은 그래프에서 어떤 시작점이 주어질 때, 다른 노드까지의 최단거리를 찾는 알고리즘이다.  
최단거리 외에, 이 때의 경로에 대해 각 노드의 이전 노드를 저장하여 출력하기도 한다.  
  
현재 노드의 이웃 노드들의 시작점부터의 거리를 계산하여,  
갱신될 때마다 이웃 노드를 큐에 담아 반복한다.  
현재 노드는 큐에서 꺼내는데, 거리가 최소인 것을 꺼낸다.  
여기서 힙 구조가 사용된다.  
큐는 시작점에서 노드까지의 거리를 기준으로 하는 최소힙이며, 거리와 노드를 담는다.

[1]: https://newbedev.com/how-can-building-a-heap-be-o-n-time-complexity
