연결 리스트는 다른 노드의 주소를 저장하여 두 노드가 연결된다.  
노드들이 메모리상에서 연속될 필요가 없어 리스트 크기의 변경이 자유롭다.  
다만 메모리 파편화가 발생하여 성능이 하락하는데, 이는 메모리 풀(memory pool)을 통해 해결한다.  
기본적인 성능은 배열에 비해 좋지 않지만, 삽입이나 삭제 시 나머지 값들을 복사할 필요가 없다.
- 탐색, 변경: O(K)
- 삽입, 삭제: O(K)
첫 번째 원소의 경우 바로 접근 및 수정이 가능하지만, 맨 마지막 원소의 경우 처음부터 N번을 이동해야 한다.  
그럼에도 해당 원소를 제외하기만 하면 되므로 삽입과 삭제에 용이하다.  
> 메모리 풀: 동일한 사이즈의 메모리 블록들을 말하며, 이 고정된 영역에 동적 할당을 수행한다.  
> 메모리 영역의 범위를 좁히므로 캐시 적중률을 높일 수 있고, 메모리 해제 등의 관리도 한 번에 할 수 있다.
> 페이징은 OS 차원에서 이루어지고, 메모리 풀은 컴파일러 차원에서 이루어진다.
### 단일 연결 리스트 (Singly Linked List)
단순 연결 리스트라고도 하며, 위의 설명대로 다음 노드에 대한 참조만을 가진다.  
체인이 끊기면 그 뒤의 자료를 잃는다.
> **FAT**(File Allocation Table. 파일 할당 테이블) 파일 시스템이 단일 연결 리스트를 사용한다.  
> 따라서 파일 유실의 위험성이 있고, 공간 효율이나 성능도 좋지 않은 시스템이다.
### 이중 연결 리스트 (Doubly Linked List)
두 개의 참조를 가지며, 각각 앞뒤 노드를 가리킨다.  
가리키고 있는 원소의 삽입, 삭제는 O(1)이라고 표현할 수 있다.  
(단일 연결 리스트는 앞 노드의 위치를 알 수 없으므로, 결국 맨 앞에서부터 앞 노드를 찾아야 한다.)  
다만 참조를 두 배로 관리해야 하며, 노드 유실에 대한 대비도 따로 처리해줘야 한다.
### 원형 연결 리스트 (Circular Linked List)
마지막 노드와 처음 노드를 연결시킨다.  
스트림 버퍼의 구현에 많이 사용되며, 큐를 구현하는 데에도 적합하다.
### 청크 리스트 (Chunked List)
원소가 배열인 리스트로, 둘의 장점을 합쳤다.  
CPU 캐시가 있는 경우, 연결 리스트는 지역성이 떨어져 성능이 저하되는데 이를 보완할 수 있다.
