## OS (Operating System. 운영체제)
- 자원 상태 파악, 분배를 위한 스케줄링
- 입출력 장치, 사용자 프로그램 제어
- 종류: 윈도우, 리눅스, 유닉스, 맥, 안드로이드
- 구조: 쉘(인터페이스. 바깥 부분)과 커널(핵심 기능. 내부 역할)
#### 윈도우, 유닉스 계열
- 윈도우: GUI, 선점형 멀티태스킹
- 유닉스: 대화식, 다중 작업, 다중 사용자
#### 유닉스, 리눅스
- 리눅스: 대부분 무료, 개인, 오픈소스
- 유닉스: 대부분 유료, 메인프레임이나 워크스테이션 등 대형 시스템, 사업자에 의한 배포

## 운용 기법
- 실시간 처리(Real-Time Processing): 즉시 처리. 빠르고 싸다.
- 시분할(Time Sharing): 시간을 균등하게 분할. 모든 사용자에게 똑같은 서비스 제공. 라운드 로빈 스케줄링
- 일괄처리(Batch Processing): 모아서 한번에 처리. 효율적.
- 분산처리(Distributed Processing): 데이터베이스에 네트워크로 연결시켜 하나의 시스템인 것처럼 처리
## 스케줄링
### 선점형(Preemptive)
#### RR (Round Robin. 라운드 로빈)
- 시간 할당이 작아지면 프로세스-문맥 교환이 자주 일어남
- Time Sharing System을 위해 고안
- 시간 할당이 커지면 FCFS 스케줄링과 같은 효과를 얻을 수 있다.
#### SRT (Shortest Remaining Time First)
- 짧은 수행 시간 프로세스 우선 수행
- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 있다.
#### MLQ (Multi-Level Queue. 다단계 큐)
- 독립된 스케줄링 큐
#### MFQ (Multi-level Feedback Queue. 다단계 피드백 큐)
- FIFO + RR. 마지막 단계를 RR로 처리
### 비선점형(Non-preemptive)
#### Priority (우선순위)
- 우선순위에 따라 할당, 동순위는 FCFS 처리
- 주요/긴급 프로세스 우선처리
#### Deadline (기한부)
- 기한 내에 완료되도록 계획
- 요청에 명시된 기한 보장
#### FCFS (First Come First Service)
- FIFO
#### SJF (Shortest Job First)
- 서비스 시간이 가장 작은 프로세스가 자원 점유
- 기아 현상 발생 가능성
#### HRN (Highest Response-ratio Next)
- SJF 보완. 대기시간이 길어지면 우선순위가 높아진다.  
우선순위 = (대기시간 + 서비스시간) / 서비스시간 = 1 + 대기시간/서비스시간
## 메모리 관리
- 반입: when
- 배치: where
- 할당: how
- 교체: who
#### 배치
- 최초 적합: 첫 번째 공간
- 최적 적합: 크기가 비슷한 공간
- 최악 적합: 가장 큰 공간
#### 할당
- 연속 할당: 단일 분할 할당, 다중 분할 할당
- 분산 할당: 페이징 기법, 세그먼테이션 기법, 페이징/세그먼테이션 기법
##### 페이징
가상 메모리 고정 크기 분할 -> 물리 메모리도 동일한 크기로 분할하여 적재  
일정한 크기의 블록을 페이지라고 한다.
##### 세그먼테이션
가상 메모리 가변 크기 분할. 배열이나 함수 같은 가변 크기 관리  
가변 크기의 블록을 세그먼트라고 한다.
##### 페이징/세그먼테이션
세그먼트를 정수 배의 부분 페이지로 다시 분할
#### 교체
- FIFO (First In First Out): 가장 먼저 들어온 페이지 교체
- LRU (Least Recently Used): 가장 오래 사용되지 않은 페이지 교체
- LFU (Least Frequently Used): 사용 횟수가 가장 적은 페이지 교체
- OPT (OPTimal replacement): 앞으로 가장 오래 사용되지 않을 페이지 교체
- NUR (Not Used Recently): LRU와 비슷. 최근 사용 여부를 확인하기 위해 페이지마다 참조 비트와 변형 비트 사용
- SCR (Second Change Replacement): LRU + LFU. 가장 오래 사용되지 않은 페이지 중 자주 사용되는 페이지 교체 방지
### 메모리 단편화 해결
- 내부 단편화 해결: Slab Allocator
- 외부 단편화 해결: 버디 메모리 할당, 통합, 압축

## 현상
#### Locality (지역성, 국부성, 구역성, 국소성)
어느 시점에 특정 부분을 집중적으로 참조.
- 시간 지역성: 스택, 순환, 서브루틴
- 공간 지역성: 배열, 순차
#### Thrashing (스레싱)
프로세스 처리 시간보다 페이지 교체 시간이 더 많아지는 현상
#### Working Set (워킹 셋)
프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합
#### Prepaging (프리페이징)
사용될 페이지를 예측하여 미리 적재
#### Deadlock (교착상태)
다중프로세싱 환경에서 둘 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태
##### 발생 조건
- 상호배제 (Mutual Exclusive)
- 점유와 대기 (Block & Wait)
- 비선점 (Non Preemption)
- 환형 대기 (Circular Wait)
#### 해결 방법
- 예방(Prevention): 점유 자원 해제 후 새 자원 요청
- 회피(Avoidance): Banker's Algorithm, Wound-Wait, Wait-Die
- 발견(Detection): 자원할당 그래프, Wait for Graph
- 복구(Recovery): 프로세스 kill, 자원 선점

